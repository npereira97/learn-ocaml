<h2>Demo Exercise: Binary Trees</h2>

<p>
  In this exercise we work with binary trees, as described by the type <code>tree</code> given in the prelude.
</p>

<p>
  For each function you are asked to implement, you are also required to write a list of <em>test cases</em> for that function. A test case is an <code>(input, output)</code> pair. You can see an example test case given for the <code>size</code> function.
</p>

<p>
  The test cases you write will be run against the solution to ensure that they are correct tests. If all of your tests are correct, we will check that you have written a good variety of tests by running them against a set of buggy implementations. The goal is for your test suite to be able to catch the bug in each of our faulty implementations.
</p>

<p>
  If your test suite for a given function is determined to be insufficient, your grade for that question will be capped at 50%.
</p>

<ol>
  <li>
    Write a function <code>size: tree -> int</code> which calculates the number of nodes in a binary tree. Write test cases for this function in the variable <code>size_tests</code>.
  </li>

  <li>
    Write a function <code>height: tree -> int</code> which returns the height of a binary tree. Recall that the <em>height</em> of a tree is the length of the longest path from the root to a leaf. The empty tree has height 0. Write test cases for this function in the variable <code>height_tests</code>.
  </li>

  <li>
    Write a function <code>num_leaves: tree -> int</code> which returns the number of leaves in a binary tree. Write test cases for this function in the variable <code>num_leaves_tests</code>.
  </li>
</ol>
